#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of Settings - a value holder class
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import os, simplejson, copy, time, types
from threading import Thread, Lock, Event

# --- Value holder for shared settings   -----------------------------------

class Settings(object):
  """ Object with shared settings """

  # initialize object   ----------------------------------------------------

  def __init__(self,parser):
    """ Constructor """

    # public fields
    self.config_parser = parser
    self.debug      = self.get_value('GLOBAL','debug','0')
    self.MAX_ALARMS = int(self.get_value('GLOBAL','max_alarms','4'))
    self.stop_event = Event()
    self.alarm_provider = []                   # calls backs for alarm-threads

    # private fields
    default_store  = os.path.join(os.path.expanduser("~"),"settings.json")
    self._store    = self.get_value('GLOBAL','store',default_store)
    if self._store != default_store:
      defaults = os.path.join(os.path.dirname(self._store),"defaults.json")
    else:
      defaults = os.path.join(os.path.expanduser("~"),"defaults.json")
    self._values   = {}
    self._listener = {}
    self._lock     = Lock()
    self._savelock = Lock()

    # initialize settings with defaults
    self.load(defaults)

  # --- return all keys+values in a configuration section   ------------------

  def get_values(self,section):
    """ return all key/values of a configuration-section """

    if self.config_parser.has_section(section):
      return self.config_parser.items(section)
    else:
      return []

  # --- read a configuration value   -----------------------------------------

  def get_value(self,section,option,default):
    """ get value of config-variables and return given default if unset """

    if self.config_parser.has_section(section):
      try:
        value = self.config_parser.get(section,option)
      except:
        value = default
    else:
      value = default
    return value

  # --- load settings   ----------------------------------------------------

  def load(self,store=None):
    if not store:
      store = self._store
    if not os.path.isfile(store):
      if hasattr(self,"log"):
        self.log.msg("file %s does not exist - skipping" % store)
      return
    if hasattr(self,"log"):
      self.log.msg("Loading settings from %s" % store)

    f = open(store,"r")
    obj = simplejson.load(f)

    # convert json-object to settings
    keys = obj.keys()
    for key in keys:
      if not key.startswith('_'):
        self._values[key] = obj[key]
    f.close()

  # --- save settings   ----------------------------------------------------

  def save(self,wait=True):
    if self._savelock.acquire(False):
      if wait:
        # we wait a few seconds to collect multiple changes
        delay = 15
        self.log.msg("Saving settings to %s in %d s" % (self._store,delay))
        time.sleep(delay)
      f = open(self._store,"w")

      jsonobj = {}
      for key in self._values.keys():
        if not key.startswith('_'):
          jsonobj[key] = self._values[key]

      # cleanup settings data
      for i in range(self.MAX_ALARMS):
        key = "alarm.%d.state" % (i+1)
        state = jsonobj[key]
        if state in ["ringing","snooze"]:
          jsonobj[key] = "enabled"

      self.log.msg("Saving settings to %s" % self._store)
      simplejson.dump(jsonobj,f,indent=2,sort_keys=True)
      f.close()
      self._savelock.release()
    else:
      self.log.msg("ignoring save-request due to concurrent save in progress")
      # don't do anything - data is probably saved by other thread

  # set a setting   --------------------------------------------------------

  def set(self,name,value,deep=False,notify=True):
    """ set a value """

    old_value = None
    if self._values.has_key(name):
      if deep:
        old_value = copy.deepcopy(self._values[name])
      else:
        old_value = self._values[name]

    with self._lock:
      self._values[name] = value
      if not name.startswith('_') and old_value != value:
        Thread(target=self.save).start()

    # call listeners
    if notify and self._listener.has_key(name):
      for listener in self._listener[name]:
        listener(name,old_value,value)

    return old_value

  # increment a variable   --------------------------------------------------

  def inc(self,name,notify=True):
    """ increment a value """

    value = self.get(name)
    if value is not None:
      if type(value) == types.StringType:
        value = str(int(value)+1)
      else:
        value += 1
      return self.set(name,value,notify=notify)
    else:
      return self.set(name,1,notify=notify)

  # decrement a variable   --------------------------------------------------

  def dec(self,name,notify=True):
    """ decrement a value """

    value = self.get(name)
    if value is not None:
      if type(value) == types.StringType:
        value = str(int(value)-1)
      else:
        value -= 1
      return self.set(name,value,notify=notify)
    else:
      return self.set(name,-1,notify=notify)

  # query a setting   -------------------------------------------------------

  def get(self,name,deep=False):
    """ query a value by name """

    if self._values.has_key(name):
      if deep:
        return copy.deepcopy(self._values[name])
      else:
        return self._values[name]
    else:
      return None

  # add settings listener   -------------------------------------------------

  def add_settings_listener(self,name,func):
    """ add a change-listener for attribute name """

    with self._lock:
      if self._listener.has_key(name):
        self._listener[name].append(func)
      else:
        self._listener[name] = [func]

  # add alarm-provider   ----------------------------------------------------

  def add_alarm_provider(self,func):
    """ add an alarm-provider callback """

    with self._lock:
      self.alarm_provider.append(func)
